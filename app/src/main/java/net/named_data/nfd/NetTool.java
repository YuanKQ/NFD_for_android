package net.named_data.nfd;

import android.app.ProgressDialog;
import android.content.Context;
import android.os.Handler;
import android.util.Log;
import android.widget.Toast;

import net.named_data.jndn.Data;
import net.named_data.jndn.Face;
import net.named_data.jndn.Interest;
import net.named_data.jndn.InterestFilter;
import net.named_data.jndn.Name;
import net.named_data.jndn.OnData;
import net.named_data.jndn.OnInterestCallback;
import net.named_data.jndn.OnRegisterFailed;
import net.named_data.jndn.OnTimeout;
import net.named_data.jndn.security.KeyChain;
import net.named_data.jndn.security.KeyType;
import net.named_data.jndn.security.identity.IdentityManager;
import net.named_data.jndn.security.identity.MemoryIdentityStorage;
import net.named_data.jndn.security.identity.MemoryPrivateKeyStorage;
import net.named_data.jndn.security.policy.SelfVerifyPolicyManager;
import net.named_data.jndn.util.Blob;
import net.named_data.jndn_xx.util.FaceUri;
import net.named_data.nfd.utils.NfdcHelper;

import java.io.IOException;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

/**
 * Created by yuan on 16-4-30.
 *
 * Function: Acquire the IP address in a LAN
 */
class NetTool {
    private final static String PREFIX = "/ndn/broadcast/ChronoChat-0.3";
    private Context m_ctx;
    private String m_prefix = "/ndn/test/broadcast/ChronoChat-0.3";
    private static final String TAG = "CChat";
    private String m_hubPrefix;
    private String m_chatRoom;
    private final ArrayList<HashMap<String, String>> m_faceList = new ArrayList<HashMap<String, String>>(); //[IP] sessionNo
    private final String m_ping = "ping -c 1 -w 0.5 ";//Must end with an space
    private final Runtime m_run = Runtime.getRuntime();
    private String m_IP;
    private NetThread m_netThread;
    private int m_session;

    public NetTool(Context ctx, String hubPrefix, String chatRoom, int session) {
        //Log.i(TAG, "NetTool hubPrefix:" + hubPrefix + " chatRoom:" + chatRoom);

        this.m_ctx = ctx;
        this.m_hubPrefix = hubPrefix;
        this.m_chatRoom = chatRoom;
        m_session = session;
        m_IP = getLocAddr();
        m_netThread = new NetThread();
        m_netThread.start();

        HashMap<String, String>map = new HashMap<String, String>();
        map.put(m_IP, String.valueOf(session));
        m_faceList.add(map);

        Log.i(TAG, "m_IP: " + m_IP);

//        Toast.makeText(m_ctx, "create netTool!", Toast.LENGTH_LONG);
    }

    //send an msg to the target IP address, to make sure that whether the target has installed the NFD
    public boolean sendMsg(String ip) {
        Face face = new Face(ip);
        Echo echo = new Echo();
        Name name = new Name(m_prefix + "/" + System.currentTimeMillis() + "/000000" + m_hubPrefix
                + "/111111" + m_chatRoom + "/222222/" + m_IP + "/333333/" + m_session);

        try {
            face.expressInterest(name, echo, echo);
            while (echo.getCallbackCount_() < 1) {
                face.processEvents();
                Thread.sleep(5);
            }
        } catch (Exception exception) {
            Log.e(TAG, "Exception happend in sendMsg to " + ip);
            return false;
        }

        if (echo.isTimeout_())
            return false;

        return true;
    }

    public void scan() {
        final ProgressDialog proDlg = ProgressDialog.show(m_ctx, "", "waiting...");
        final String preAddress = getLocAddrIndex();

        if (preAddress.equals("")) {
            Toast.makeText(m_ctx, "Please connect to the WIFI first.",
                    Toast.LENGTH_LONG).show();
            return;
        }

        for (int i = 0; i < 256; i ++) {
            final int lastAddres = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    Process proc = null;
                    try {
                        String p = m_ping + preAddress + lastAddres;
                        String curIP = preAddress + lastAddres;
                        proc = m_run.exec(p);

                        int result = proc.waitFor();
                        if (result == 0) {
                            //Log.i(TAG, "Successfully connect to " + curIP);
                            //if (sendMsg(curIP)) //!curIP.equals(m_IP) &&
                                //Log.i(TAG, curIP + "has installed NFD.");
                            sendMsg(curIP);
                        }
                    } catch (Exception e) {
                        Log.e(TAG, "Exception happened for " + e.getMessage());
                    } finally {
                        proc.destroy();
                    }
                }
            }).start();
        }


        new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                //Log.i(TAG, "progressDlg End!");
                proDlg.dismiss();

            }
        }, 30000);

    }

    public String getLocAddrIndex() {
//        String str = getLocAddr();
        //Log.i(TAG, "My IP:" + m_IP);

        if (!m_IP.equals("")) {
            for (int i = 0; i < 256; i ++) {
                //Log.i(TAG, m_IP.substring(0, m_IP.lastIndexOf(".") + 1));
                return m_IP.substring(0, m_IP.lastIndexOf(".") + 1);
            }
        }

        return null;
    }

    public String getLocAddr() {
        try {
            Enumeration en = NetworkInterface.getNetworkInterfaces();
            while (en.hasMoreElements()) {
                NetworkInterface networks = (NetworkInterface)en.nextElement();
                Enumeration address = networks.getInetAddresses();
                while (address.hasMoreElements()) {
                    InetAddress ip = (InetAddress)address.nextElement();
                    if (!ip.isLoopbackAddress() && !ip.isLinkLocalAddress())
                        return ip.getHostAddress().toString();
                }
            }
        } catch (SocketException e) {
            Log.e(TAG, "Fail to get localhost: " + e.getMessage());
        }
        return null;
    }

    class Echo implements OnData, OnTimeout, OnInterestCallback, OnRegisterFailed {

        private long callbackCount_ = 0;
        private boolean isTimeout_ = false;
        private KeyChain keyChain_;
        private Name certificateName_;

        public Echo(KeyChain keyChain, Name certificateName) {
            keyChain_ = keyChain;
            certificateName_ = certificateName;
        }

        public Echo() {
        }

        @Override
        public void onData(Interest interest, Data data) {
            ++ callbackCount_;
            String content = data.getContent().toString();
            //Log.i(TAG, ">>onData:" + content);
//            int i = 0;
//            if (content.startsWith("/"))
//                i = 1;
//            String[] strs =content.split("/");
//            if (m_faceList.size() < strs.length) {
//                for (; i < strs.length; i++) {
//                    if (!m_faceList.contains(strs[i])) {
//                        m_faceList.add(strs[i]);
//                        registerBroadcastPrefix(strs[i]);
//                        //Log.i(TAG, "Add FaceUri[" + i + "]" + strs[i]);
//                    }
//                }
//            }


            if (content.startsWith("/"))
                content = content.substring(1);
            //Log.i(TAG, "content: " + content);

            String[] strs = content.split("/");
            for (String str: strs) {
                if (str.equals(""))
                    continue;
                String[] tmpStrs = str.split("=");
                //Log.i(TAG, str);
//                for (String str1: tmpStrs)
//                    Log.i(TAG, "    tmpStr:" + str1);

                boolean isExist = false;
                for (int i = 0; i < m_faceList.size(); ++ i) {
                    HashMap<String, String> tmpMap = m_faceList.get(i);
                    if (tmpMap.containsKey(tmpStrs[0])) {
                        isExist = true;
                        if (tmpMap.containsValue(tmpStrs[1])) {
                            //Log.i(TAG, "m_faceList has contain:" + tmpMap);
                            break;
                        }

                        //replace and update
                        m_faceList.remove(tmpMap);
                        //Log.i(TAG, "remove tmpMap: " + tmpMap);
                        HashMap<String,String> itemMap = new HashMap<String, String>();
                        itemMap.put(tmpStrs[0], tmpStrs[1]);
                        m_faceList.add(itemMap);
                        break;
                    }
//                    else registerBroadcastPrefix(tmpStrs[0]);
//
//                    //add new item
//                    HashMap<String,String> itemMap = new HashMap<String, String>();
//                    itemMap.put(tmpStrs[0], tmpStrs[1]);
//                    m_faceList.add(itemMap);
//                    //Log.i(TAG, "m_faceList add new item: " + itemMap);
                }

                if (!isExist) {
                    registerBroadcastPrefix(tmpStrs[0]);

                    //add new item
                    HashMap<String,String> itemMap = new HashMap<String, String>();
                    itemMap.put(tmpStrs[0], tmpStrs[1]);
                    m_faceList.add(itemMap);
                    //Log.i(TAG, "m_faceList add new item: " + itemMap);
                }
            }

//            for (int i = 0; i < m_faceList.size(); ++ i) {
//                //Log.i(TAG, "m_faceList[" + i + "]" + m_faceList.get(i));
//            }
        }

        private void registerBroadcastPrefix(String str) {
            //Log.i(TAG, "FaceUri:" + str + " prefix:" + (new Name(PREFIX + m_chatRoom)).toString());

            NfdcHelper nfdcHelper = new NfdcHelper();
            try {
                int faceID = nfdcHelper.faceCreate("tcp4://" + str);
                nfdcHelper.ribRegisterPrefix(new Name(PREFIX + m_chatRoom), faceID,
                        10, true, false);
            }
            catch (FaceUri.CanonizeError e) {
                Log.e(TAG, "1.Error creating face (" + e.getMessage() + ")");
            }
            catch (FaceUri.Error e) {
                Log.e(TAG, "2.Error creating face (" + e.getMessage() + ")");
            }
            catch (Exception e) {
                Log.e(TAG, "Error communicating with NFD (" + e.getMessage() + ")");
            }
            finally {
                nfdcHelper.shutdown();
            }

        }

        @Override
        public void onTimeout(Interest interest) {
            ++ callbackCount_;
            isTimeout_ = true;
            Log.i(TAG, "Time out for interest " + interest.getName().toString());
        }


        @Override
        public void onRegisterFailed(Name prefix) {
            Log.e(TAG, "Register failed for prefix " + prefix.toUri());
        }

        @Override
        public void onInterest(Name prefix, Interest interest, Face face, long interestFilterId, InterestFilter filter) {
            String interestStr = interest.getName().toString();
            Log.i(TAG, ">>OnInterest:" + interestStr);
            String strs[] = interestStr.split("/");
            String hubPrefix = "";
            String chatRoom = "";
            String targetIP = "";
            String targetSession = "";
            int start = -1;
            for (int i = 0; i < strs.length; i ++) {
                if (strs[i].equals("000000")) {
                    start = 0;
                    continue;
                }
                else if (strs[i].equals("111111")) {
                    start = 1;
                    continue;
                }
                else if (strs[i].equals("222222")) {
                    start = 2;
                    continue;
                }
                else if (strs[i].equals("333333")) {
                    start = 3;
                    continue;
                }


                if (start == 0)
                    hubPrefix = hubPrefix + "/" + strs[i];
                else if (start == 1)
                    chatRoom = chatRoom + "/" + strs[i];
                else if (start == 2)
                    targetIP = strs[i];
                else if (start == 3)
                    targetSession = strs[i];
            }

            Log.i(TAG, ">> hubPrefix:" + hubPrefix);
            Log.i(TAG, ">> chatRoom:" + chatRoom);
            Log.i(TAG, ">> targetIP:" + targetIP);
            Log.i(TAG, ">> targetSession:" + targetSession);

            if (hubPrefix.equals(m_hubPrefix) && chatRoom.equals(m_chatRoom)) {
//                m_faceList.add(targetIP);
//                registerBroadcastPrefix(targetIP);
                //establish remoteFace:targetIP, register "/ndn/broadcast/ChronoChat-0.3/" + chatRoom
                for (int i = 0; i < m_faceList.size(); ++ i) {
                    HashMap<String, String> tmpMap = m_faceList.get(i);
                    if (tmpMap.containsKey(targetIP)) {
                        if (tmpMap.containsValue(targetSession))
                            return;

                        //replace and update
                        m_faceList.remove(tmpMap);
                        HashMap<String,String> itemMap = new HashMap<String, String>();
                        itemMap.put(targetIP, targetSession);
                        m_faceList.add(itemMap);
                        return;
                    }
                }
                registerBroadcastPrefix(targetIP);
                HashMap<String,String> itemMap = new HashMap<String, String>();
                itemMap.put(targetIP, targetSession);
                m_faceList.add(itemMap);
                Log.i(TAG, "m_faceList add item: " + itemMap);
            }

            Data data = new Data(interest.getName());
            String content = "";
            for (int i = 0; i < m_faceList.size(); i ++) {
                HashMap<String, String> map = m_faceList.get(i);
                Set<String> keySet = map.keySet();
                for (Iterator iter = keySet.iterator(); iter.hasNext();) {
                    String key = (String)iter.next();
                    String value = map.get(key);
                    content = content + "/" + key + "=" + value;
                }
            }

            data.setContent(new Blob(content));
            try {
                keyChain_.sign(data, certificateName_);
            } catch (net.named_data.jndn.security.SecurityException e) {
                throw new Error("SecurityException in sign: " + e.getMessage());
            }
            try {
                face.putData(data);
                Log.i(TAG, ">>send content: " + content);
                //sendDebugMsg(content);
            } catch (IOException ex) {
                Log.e(TAG, "Echo: IOException in sending data " + ex.getMessage());
            }
        }

        public boolean isTimeout_() {
            return isTimeout_;
        }

        public long getCallbackCount_() {
            return callbackCount_;
        }
    }

    private class NetThread extends Thread {

        public void run() {
            try {
                //Log.i(TAG, "NetThread run()!");

                netFace_ = new Face();
                MemoryIdentityStorage identityStorage = new MemoryIdentityStorage();
                MemoryPrivateKeyStorage privateKeyStorage = new MemoryPrivateKeyStorage();
                KeyChain keyChain = new KeyChain
                        (new IdentityManager(identityStorage, privateKeyStorage),
                                new SelfVerifyPolicyManager(identityStorage));
                keyChain.setFace(netFace_);

                // Initialize the storage.
                Name keyName = new Name("/testname/DSK-123");
                Name certificateName = keyName.getSubName(0, keyName.size() - 1).append
                        ("KEY").append(keyName.get(-1)).append("ID-CERT").append("0");
//                //Log.i(TAG, certificateName.toString());
                identityStorage.addKey(keyName, KeyType.RSA, new Blob(DEFAULT_RSA_PUBLIC_KEY_DER, false));
                privateKeyStorage.setKeyPairForKeyName
                        (keyName, KeyType.RSA, DEFAULT_RSA_PUBLIC_KEY_DER, DEFAULT_RSA_PRIVATE_KEY_DER);

                netFace_.setCommandSigningInfo(keyChain, certificateName);

                Echo echo = new Echo(keyChain, certificateName);
                Name prefix = new Name(m_prefix);
                netFace_.registerPrefix(prefix, echo, echo);
                //Log.i(TAG, "Register prefix  " + prefix.toUri());

                // The main event loop.
                // Wait to receive one interest for the prefix.
                //while (echo.responseCount_ < 100) {
                while (true) {
                    netFace_.processEvents();
                    Thread.sleep(5);
                }
            } catch (Exception e) {
                Log.e(TAG, "exception: " + e.getMessage());
            }
        }

        public void netFace_Close() {
            if (netFace_ != null) {
                //netFace_.removeRegisteredPrefix(registerPrefixId);
                netFace_.shutdown();
                //Log.i(TAG, "netFace_Close()!");
            }
        }
        private Face netFace_;
    }

    private static final ByteBuffer DEFAULT_RSA_PUBLIC_KEY_DER = toBuffer(new int[]{
            0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
            0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
            0x00, 0xb8, 0x09, 0xa7, 0x59, 0x82, 0x84, 0xec, 0x4f, 0x06, 0xfa, 0x1c, 0xb2, 0xe1, 0x38, 0x93,
            0x53, 0xbb, 0x7d, 0xd4, 0xac, 0x88, 0x1a, 0xf8, 0x25, 0x11, 0xe4, 0xfa, 0x1d, 0x61, 0x24, 0x5b,
            0x82, 0xca, 0xcd, 0x72, 0xce, 0xdb, 0x66, 0xb5, 0x8d, 0x54, 0xbd, 0xfb, 0x23, 0xfd, 0xe8, 0x8e,
            0xaf, 0xa7, 0xb3, 0x79, 0xbe, 0x94, 0xb5, 0xb7, 0xba, 0x17, 0xb6, 0x05, 0xae, 0xce, 0x43, 0xbe,
            0x3b, 0xce, 0x6e, 0xea, 0x07, 0xdb, 0xbf, 0x0a, 0x7e, 0xeb, 0xbc, 0xc9, 0x7b, 0x62, 0x3c, 0xf5,
            0xe1, 0xce, 0xe1, 0xd9, 0x8d, 0x9c, 0xfe, 0x1f, 0xc7, 0xf8, 0xfb, 0x59, 0xc0, 0x94, 0x0b, 0x2c,
            0xd9, 0x7d, 0xbc, 0x96, 0xeb, 0xb8, 0x79, 0x22, 0x8a, 0x2e, 0xa0, 0x12, 0x1d, 0x42, 0x07, 0xb6,
            0x5d, 0xdb, 0xe1, 0xf6, 0xb1, 0x5d, 0x7b, 0x1f, 0x54, 0x52, 0x1c, 0xa3, 0x11, 0x9b, 0xf9, 0xeb,
            0xbe, 0xb3, 0x95, 0xca, 0xa5, 0x87, 0x3f, 0x31, 0x18, 0x1a, 0xc9, 0x99, 0x01, 0xec, 0xaa, 0x90,
            0xfd, 0x8a, 0x36, 0x35, 0x5e, 0x12, 0x81, 0xbe, 0x84, 0x88, 0xa1, 0x0d, 0x19, 0x2a, 0x4a, 0x66,
            0xc1, 0x59, 0x3c, 0x41, 0x83, 0x3d, 0x3d, 0xb8, 0xd4, 0xab, 0x34, 0x90, 0x06, 0x3e, 0x1a, 0x61,
            0x74, 0xbe, 0x04, 0xf5, 0x7a, 0x69, 0x1b, 0x9d, 0x56, 0xfc, 0x83, 0xb7, 0x60, 0xc1, 0x5e, 0x9d,
            0x85, 0x34, 0xfd, 0x02, 0x1a, 0xba, 0x2c, 0x09, 0x72, 0xa7, 0x4a, 0x5e, 0x18, 0xbf, 0xc0, 0x58,
            0xa7, 0x49, 0x34, 0x46, 0x61, 0x59, 0x0e, 0xe2, 0x6e, 0x9e, 0xd2, 0xdb, 0xfd, 0x72, 0x2f, 0x3c,
            0x47, 0xcc, 0x5f, 0x99, 0x62, 0xee, 0x0d, 0xf3, 0x1f, 0x30, 0x25, 0x20, 0x92, 0x15, 0x4b, 0x04,
            0xfe, 0x15, 0x19, 0x1d, 0xdc, 0x7e, 0x5c, 0x10, 0x21, 0x52, 0x21, 0x91, 0x54, 0x60, 0x8b, 0x92,
            0x41, 0x02, 0x03, 0x01, 0x00, 0x01
    });

    // Java uses an unencrypted PKCS #8 PrivateKeyInfo, not a PKCS #1 RSAPrivateKey.
    private static final ByteBuffer DEFAULT_RSA_PRIVATE_KEY_DER = toBuffer(new int[]{
            0x30, 0x82, 0x04, 0xbf, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
            0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x04, 0xa9, 0x30, 0x82, 0x04, 0xa5, 0x02, 0x01,
            0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xb8, 0x09, 0xa7, 0x59, 0x82, 0x84, 0xec, 0x4f, 0x06, 0xfa,
            0x1c, 0xb2, 0xe1, 0x38, 0x93, 0x53, 0xbb, 0x7d, 0xd4, 0xac, 0x88, 0x1a, 0xf8, 0x25, 0x11, 0xe4,
            0xfa, 0x1d, 0x61, 0x24, 0x5b, 0x82, 0xca, 0xcd, 0x72, 0xce, 0xdb, 0x66, 0xb5, 0x8d, 0x54, 0xbd,
            0xfb, 0x23, 0xfd, 0xe8, 0x8e, 0xaf, 0xa7, 0xb3, 0x79, 0xbe, 0x94, 0xb5, 0xb7, 0xba, 0x17, 0xb6,
            0x05, 0xae, 0xce, 0x43, 0xbe, 0x3b, 0xce, 0x6e, 0xea, 0x07, 0xdb, 0xbf, 0x0a, 0x7e, 0xeb, 0xbc,
            0xc9, 0x7b, 0x62, 0x3c, 0xf5, 0xe1, 0xce, 0xe1, 0xd9, 0x8d, 0x9c, 0xfe, 0x1f, 0xc7, 0xf8, 0xfb,
            0x59, 0xc0, 0x94, 0x0b, 0x2c, 0xd9, 0x7d, 0xbc, 0x96, 0xeb, 0xb8, 0x79, 0x22, 0x8a, 0x2e, 0xa0,
            0x12, 0x1d, 0x42, 0x07, 0xb6, 0x5d, 0xdb, 0xe1, 0xf6, 0xb1, 0x5d, 0x7b, 0x1f, 0x54, 0x52, 0x1c,
            0xa3, 0x11, 0x9b, 0xf9, 0xeb, 0xbe, 0xb3, 0x95, 0xca, 0xa5, 0x87, 0x3f, 0x31, 0x18, 0x1a, 0xc9,
            0x99, 0x01, 0xec, 0xaa, 0x90, 0xfd, 0x8a, 0x36, 0x35, 0x5e, 0x12, 0x81, 0xbe, 0x84, 0x88, 0xa1,
            0x0d, 0x19, 0x2a, 0x4a, 0x66, 0xc1, 0x59, 0x3c, 0x41, 0x83, 0x3d, 0x3d, 0xb8, 0xd4, 0xab, 0x34,
            0x90, 0x06, 0x3e, 0x1a, 0x61, 0x74, 0xbe, 0x04, 0xf5, 0x7a, 0x69, 0x1b, 0x9d, 0x56, 0xfc, 0x83,
            0xb7, 0x60, 0xc1, 0x5e, 0x9d, 0x85, 0x34, 0xfd, 0x02, 0x1a, 0xba, 0x2c, 0x09, 0x72, 0xa7, 0x4a,
            0x5e, 0x18, 0xbf, 0xc0, 0x58, 0xa7, 0x49, 0x34, 0x46, 0x61, 0x59, 0x0e, 0xe2, 0x6e, 0x9e, 0xd2,
            0xdb, 0xfd, 0x72, 0x2f, 0x3c, 0x47, 0xcc, 0x5f, 0x99, 0x62, 0xee, 0x0d, 0xf3, 0x1f, 0x30, 0x25,
            0x20, 0x92, 0x15, 0x4b, 0x04, 0xfe, 0x15, 0x19, 0x1d, 0xdc, 0x7e, 0x5c, 0x10, 0x21, 0x52, 0x21,
            0x91, 0x54, 0x60, 0x8b, 0x92, 0x41, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01, 0x01, 0x00,
            0x8a, 0x05, 0xfb, 0x73, 0x7f, 0x16, 0xaf, 0x9f, 0xa9, 0x4c, 0xe5, 0x3f, 0x26, 0xf8, 0x66, 0x4d,
            0xd2, 0xfc, 0xd1, 0x06, 0xc0, 0x60, 0xf1, 0x9f, 0xe3, 0xa6, 0xc6, 0x0a, 0x48, 0xb3, 0x9a, 0xca,
            0x21, 0xcd, 0x29, 0x80, 0x88, 0x3d, 0xa4, 0x85, 0xa5, 0x7b, 0x82, 0x21, 0x81, 0x28, 0xeb, 0xf2,
            0x43, 0x24, 0xb0, 0x76, 0xc5, 0x52, 0xef, 0xc2, 0xea, 0x4b, 0x82, 0x41, 0x92, 0xc2, 0x6d, 0xa6,
            0xae, 0xf0, 0xb2, 0x26, 0x48, 0xa1, 0x23, 0x7f, 0x02, 0xcf, 0xa8, 0x90, 0x17, 0xa2, 0x3e, 0x8a,
            0x26, 0xbd, 0x6d, 0x8a, 0xee, 0xa6, 0x0c, 0x31, 0xce, 0xc2, 0xbb, 0x92, 0x59, 0xb5, 0x73, 0xe2,
            0x7d, 0x91, 0x75, 0xe2, 0xbd, 0x8c, 0x63, 0xe2, 0x1c, 0x8b, 0xc2, 0x6a, 0x1c, 0xfe, 0x69, 0xc0,
            0x44, 0xcb, 0x58, 0x57, 0xb7, 0x13, 0x42, 0xf0, 0xdb, 0x50, 0x4c, 0xe0, 0x45, 0x09, 0x8f, 0xca,
            0x45, 0x8a, 0x06, 0xfe, 0x98, 0xd1, 0x22, 0xf5, 0x5a, 0x9a, 0xdf, 0x89, 0x17, 0xca, 0x20, 0xcc,
            0x12, 0xa9, 0x09, 0x3d, 0xd5, 0xf7, 0xe3, 0xeb, 0x08, 0x4a, 0xc4, 0x12, 0xc0, 0xb9, 0x47, 0x6c,
            0x79, 0x50, 0x66, 0xa3, 0xf8, 0xaf, 0x2c, 0xfa, 0xb4, 0x6b, 0xec, 0x03, 0xad, 0xcb, 0xda, 0x24,
            0x0c, 0x52, 0x07, 0x87, 0x88, 0xc0, 0x21, 0xf3, 0x02, 0xe8, 0x24, 0x44, 0x0f, 0xcd, 0xa0, 0xad,
            0x2f, 0x1b, 0x79, 0xab, 0x6b, 0x49, 0x4a, 0xe6, 0x3b, 0xd0, 0xad, 0xc3, 0x48, 0xb9, 0xf7, 0xf1,
            0x34, 0x09, 0xeb, 0x7a, 0xc0, 0xd5, 0x0d, 0x39, 0xd8, 0x45, 0xce, 0x36, 0x7a, 0xd8, 0xde, 0x3c,
            0xb0, 0x21, 0x96, 0x97, 0x8a, 0xff, 0x8b, 0x23, 0x60, 0x4f, 0xf0, 0x3d, 0xd7, 0x8f, 0xf3, 0x2c,
            0xcb, 0x1d, 0x48, 0x3f, 0x86, 0xc4, 0xa9, 0x00, 0xf2, 0x23, 0x2d, 0x72, 0x4d, 0x66, 0xa5, 0x01,
            0x02, 0x81, 0x81, 0x00, 0xdc, 0x4f, 0x99, 0x44, 0x0d, 0x7f, 0x59, 0x46, 0x1e, 0x8f, 0xe7, 0x2d,
            0x8d, 0xdd, 0x54, 0xc0, 0xf7, 0xfa, 0x46, 0x0d, 0x9d, 0x35, 0x03, 0xf1, 0x7c, 0x12, 0xf3, 0x5a,
            0x9d, 0x83, 0xcf, 0xdd, 0x37, 0x21, 0x7c, 0xb7, 0xee, 0xc3, 0x39, 0xd2, 0x75, 0x8f, 0xb2, 0x2d,
            0x6f, 0xec, 0xc6, 0x03, 0x55, 0xd7, 0x00, 0x67, 0xd3, 0x9b, 0xa2, 0x68, 0x50, 0x6f, 0x9e, 0x28,
            0xa4, 0x76, 0x39, 0x2b, 0xb2, 0x65, 0xcc, 0x72, 0x82, 0x93, 0xa0, 0xcf, 0x10, 0x05, 0x6a, 0x75,
            0xca, 0x85, 0x35, 0x99, 0xb0, 0xa6, 0xc6, 0xef, 0x4c, 0x4d, 0x99, 0x7d, 0x2c, 0x38, 0x01, 0x21,
            0xb5, 0x31, 0xac, 0x80, 0x54, 0xc4, 0x18, 0x4b, 0xfd, 0xef, 0xb3, 0x30, 0x22, 0x51, 0x5a, 0xea,
            0x7d, 0x9b, 0xb2, 0x9d, 0xcb, 0xba, 0x3f, 0xc0, 0x1a, 0x6b, 0xcd, 0xb0, 0xe6, 0x2f, 0x04, 0x33,
            0xd7, 0x3a, 0x49, 0x71, 0x02, 0x81, 0x81, 0x00, 0xd5, 0xd9, 0xc9, 0x70, 0x1a, 0x13, 0xb3, 0x39,
            0x24, 0x02, 0xee, 0xb0, 0xbb, 0x84, 0x17, 0x12, 0xc6, 0xbd, 0x65, 0x73, 0xe9, 0x34, 0x5d, 0x43,
            0xff, 0xdc, 0xf8, 0x55, 0xaf, 0x2a, 0xb9, 0xe1, 0xfa, 0x71, 0x65, 0x4e, 0x50, 0x0f, 0xa4, 0x3b,
            0xe5, 0x68, 0xf2, 0x49, 0x71, 0xaf, 0x15, 0x88, 0xd7, 0xaf, 0xc4, 0x9d, 0x94, 0x84, 0x6b, 0x5b,
            0x10, 0xd5, 0xc0, 0xaa, 0x0c, 0x13, 0x62, 0x99, 0xc0, 0x8b, 0xfc, 0x90, 0x0f, 0x87, 0x40, 0x4d,
            0x58, 0x88, 0xbd, 0xe2, 0xba, 0x3e, 0x7e, 0x2d, 0xd7, 0x69, 0xa9, 0x3c, 0x09, 0x64, 0x31, 0xb6,
            0xcc, 0x4d, 0x1f, 0x23, 0xb6, 0x9e, 0x65, 0xd6, 0x81, 0xdc, 0x85, 0xcc, 0x1e, 0xf1, 0x0b, 0x84,
            0x38, 0xab, 0x93, 0x5f, 0x9f, 0x92, 0x4e, 0x93, 0x46, 0x95, 0x6b, 0x3e, 0xb6, 0xc3, 0x1b, 0xd7,
            0x69, 0xa1, 0x0a, 0x97, 0x37, 0x78, 0xed, 0xd1, 0x02, 0x81, 0x80, 0x33, 0x18, 0xc3, 0x13, 0x65,
            0x8e, 0x03, 0xc6, 0x9f, 0x90, 0x00, 0xae, 0x30, 0x19, 0x05, 0x6f, 0x3c, 0x14, 0x6f, 0xea, 0xf8,
            0x6b, 0x33, 0x5e, 0xee, 0xc7, 0xf6, 0x69, 0x2d, 0xdf, 0x44, 0x76, 0xaa, 0x32, 0xba, 0x1a, 0x6e,
            0xe6, 0x18, 0xa3, 0x17, 0x61, 0x1c, 0x92, 0x2d, 0x43, 0x5d, 0x29, 0xa8, 0xdf, 0x14, 0xd8, 0xff,
            0xdb, 0x38, 0xef, 0xb8, 0xb8, 0x2a, 0x96, 0x82, 0x8e, 0x68, 0xf4, 0x19, 0x8c, 0x42, 0xbe, 0xcc,
            0x4a, 0x31, 0x21, 0xd5, 0x35, 0x6c, 0x5b, 0xa5, 0x7c, 0xff, 0xd1, 0x85, 0x87, 0x28, 0xdc, 0x97,
            0x75, 0xe8, 0x03, 0x80, 0x1d, 0xfd, 0x25, 0x34, 0x41, 0x31, 0x21, 0x12, 0x87, 0xe8, 0x9a, 0xb7,
            0x6a, 0xc0, 0xc4, 0x89, 0x31, 0x15, 0x45, 0x0d, 0x9c, 0xee, 0xf0, 0x6a, 0x2f, 0xe8, 0x59, 0x45,
            0xc7, 0x7b, 0x0d, 0x6c, 0x55, 0xbb, 0x43, 0xca, 0xc7, 0x5a, 0x01, 0x02, 0x81, 0x81, 0x00, 0xab,
            0xf4, 0xd5, 0xcf, 0x78, 0x88, 0x82, 0xc2, 0xdd, 0xbc, 0x25, 0xe6, 0xa2, 0xc1, 0xd2, 0x33, 0xdc,
            0xef, 0x0a, 0x97, 0x2b, 0xdc, 0x59, 0x6a, 0x86, 0x61, 0x4e, 0xa6, 0xc7, 0x95, 0x99, 0xa6, 0xa6,
            0x55, 0x6c, 0x5a, 0x8e, 0x72, 0x25, 0x63, 0xac, 0x52, 0xb9, 0x10, 0x69, 0x83, 0x99, 0xd3, 0x51,
            0x6c, 0x1a, 0xb3, 0x83, 0x6a, 0xff, 0x50, 0x58, 0xb7, 0x28, 0x97, 0x13, 0xe2, 0xba, 0x94, 0x5b,
            0x89, 0xb4, 0xea, 0xba, 0x31, 0xcd, 0x78, 0xe4, 0x4a, 0x00, 0x36, 0x42, 0x00, 0x62, 0x41, 0xc6,
            0x47, 0x46, 0x37, 0xea, 0x6d, 0x50, 0xb4, 0x66, 0x8f, 0x55, 0x0c, 0xc8, 0x99, 0x91, 0xd5, 0xec,
            0xd2, 0x40, 0x1c, 0x24, 0x7d, 0x3a, 0xff, 0x74, 0xfa, 0x32, 0x24, 0xe0, 0x11, 0x2b, 0x71, 0xad,
            0x7e, 0x14, 0xa0, 0x77, 0x21, 0x68, 0x4f, 0xcc, 0xb6, 0x1b, 0xe8, 0x00, 0x49, 0x13, 0x21, 0x02,
            0x81, 0x81, 0x00, 0xb6, 0x18, 0x73, 0x59, 0x2c, 0x4f, 0x92, 0xac, 0xa2, 0x2e, 0x5f, 0xb6, 0xbe,
            0x78, 0x5d, 0x47, 0x71, 0x04, 0x92, 0xf0, 0xd7, 0xe8, 0xc5, 0x7a, 0x84, 0x6b, 0xb8, 0xb4, 0x30,
            0x1f, 0xd8, 0x0d, 0x58, 0xd0, 0x64, 0x80, 0xa7, 0x21, 0x1a, 0x48, 0x00, 0x37, 0xd6, 0x19, 0x71,
            0xbb, 0x91, 0x20, 0x9d, 0xe2, 0xc3, 0xec, 0xdb, 0x36, 0x1c, 0xca, 0x48, 0x7d, 0x03, 0x32, 0x74,
            0x1e, 0x65, 0x73, 0x02, 0x90, 0x73, 0xd8, 0x3f, 0xb5, 0x52, 0x35, 0x79, 0x1c, 0xee, 0x93, 0xa3,
            0x32, 0x8b, 0xed, 0x89, 0x98, 0xf1, 0x0c, 0xd8, 0x12, 0xf2, 0x89, 0x7f, 0x32, 0x23, 0xec, 0x67,
            0x66, 0x52, 0x83, 0x89, 0x99, 0x5e, 0x42, 0x2b, 0x42, 0x4b, 0x84, 0x50, 0x1b, 0x3e, 0x47, 0x6d,
            0x74, 0xfb, 0xd1, 0xa6, 0x10, 0x20, 0x6c, 0x6e, 0xbe, 0x44, 0x3f, 0xb9, 0xfe, 0xbc, 0x8d, 0xda,
            0xcb, 0xea, 0x8f
    });

    private static ByteBuffer
    toBuffer(int[] array) {
        ByteBuffer result = ByteBuffer.allocate(array.length);
        for (int i = 0; i < array.length; ++i)
            result.put((byte) (array[i] & 0xff));

        result.flip();
        return result;
    }


    public String findFaceUri(String session) {
        for (int i = 0; i < m_faceList.size(); ++ i) {
            HashMap<String, String>tmpMap = m_faceList.get(i);
            //Log.i(TAG, "findFaceUri tmpMap:" + tmpMap);

            if (tmpMap.containsValue(session)) {
                for (String str: tmpMap.keySet()) {
                    //Log.i(TAG, "findFaceUri: " + str);
                    return str;
                }
            }
        }

        return null;
    }


    public void addFaceItem(String faceUri, String session) {
        HashMap<String, String>tmpMap = new HashMap<String, String>();
        tmpMap.put(faceUri, session);
        m_faceList.add(tmpMap);
    }

}

